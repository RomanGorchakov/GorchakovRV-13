# Отчет по лабораторной работе №3
# Модель многопользовательского доступа: MVCC

## Сведения о студенте
**Дата:** [2004-11-10]

**Семестр:** 7

**Группа:** ПИЖ-б-о-22-1

**Дисциплина:** Администрирование баз данных

**Студент:** Горчаков Роман Владимирович

## Цель работы
Изучить принципы многоверсионного управления конкурентным доступом (MVCC) в PostgreSQL.

Получить практические навыки наблюдения за работой MVCC, анализа версий строк, снимков данных и уровней изоляции транзакций.

Освоить использование расширений и системных представлений для исследования внутренней структуры данных.

## Теоретическая часть
### Изученные концепции
- Аномалии параллелизма: ситуации, при которых параллельное выполнение транзакций приводит к конфликтам, нарушению целостности данных или ошибкам.

### Ключевые термины
- **MVCC (Multiversion Concurrency Control):** механизм, позволяющий нескольким транзакциям работать с одними и теми же данными одновременно, минимизируя блокировки.
- **Транзакция:** последовательность одной или нескольких операций в базе данных, которая выполняется как единое целое.
- **Снимок данных:** "моментальный снимок" состояния базы данных на определённый момент времени, который каждая транзакция видит на момент своего начала.

## Практическая часть

### Модуль 1: Уровни изоляции и аномалии

#### Задача 1: Read Committed vs Удаление
**Цель:** Создать таблицу iso_test (id INT, data TEXT) и вставить одну строку, в сеансе 1 начать транзакцию с уровнем READ COMMITTED и выполнить SELECT * FROM iso_test; в сеансе 2 удалить строку и зафиксировать изменения (DELETE ...; COMMIT;), в сеансе 1 выполнить тот же SELECT повторно. Сколько строк увидите? Завершить транзакцию в сеансе 1.

**Выполненные действия:**

1. create table iso_test (id int, data text);
2. insert into iso_test values (1, 'test data');
3. begin transaction isolation level read committed;
4. select * from iso_test;
5. delete from iso_test where id = 1;
6. commit;
7. select * from iso_test;
8. commit;

**Результаты:**

1. CREATE TABLE
2. INSERT 0 1
3. BEGIN

4. 
``` id |   data    ```

``` ----+----------- ```

```  1 | test data ```

``` (1 row) ```

5. DELETE 1
6. COMMIT

7. 
``` id | data ```

``` ----+------ ```

``` (0 rows) ```

8. COMMIT

**Выводы и объяснения:**
Во втором select в сеансе 1 будет видно 0 строк. При уровне изоляции read committed каждый оператор select видит только те данные, которые были зафиксированы на момент начала выполнения этого оператора. После commit в сеансе 2, удаление становится видимым для других транзакций.

#### Задача 2: Repeatable Read vs Удаление
**Цель:** Повторить предыдущий эксперимент, но в сеансе 1 начать транзакцию с BEGIN ISOLATION LEVEL REPEATABLE READ, и объяснить разницу в результатах между двумя уровнями изоляции.

**Выполненные действия:**
1. insert into iso_test values (1, 'test data');
2. begin transaction isolation level repeatable read;
3. select * from iso_test;
4. delete from iso_test where id = 1;
5. commit;
6. select * from iso_test;
7. commit;

**Результаты:**

1. INSERT 0 1
2. BEGIN

3. 
``` id |   data    ```

``` ----+----------- ```

```  1 | test data ```

``` (1 row) ```

4. DELETE 1
5. COMMIT

6. 
``` id |   data    ```

``` ----+----------- ```

```  1 | test data ```

``` (1 row) ```

7. COMMIT

**Выводы и объяснения:**
Разница в результатах между уровнями изоляции Read Committed и Repeatable Read заключается в том, что Read Committed допускает неповторяющееся чтение, а Repeatable Read - фантомные чтения. Это связано с особенностями работы этих уровней изоляции. 

#### Задача 3: Создание таблицы в транзакции
**Цель:** В сеансе 1 начать транзакцию и создать новую таблицу new_table, вставить в неё строку, не фиксируя; в сеансе 2 выполнить SELECT * FROM new_table. Что произойдет? Зафиксировать транзакцию в сеансе 1, повторить запрос в сеансе 2,  затем ещё раз, но вместо фиксации откатить транзакцию в сеансе 1. Что изменилось?

**Выполненные действия:**

1. begin transaction isolation level read committed;
2. create table new_table (id int, data text);
3. insert into new_table values (1, 'test data');
4. select * from new_table;
5. commit;
6. select * from new_table;
7. rollback;
8. select * from new_table;

**Результаты:**

1. BEGIN
2. CREATE TABLE
3. INSERT 0 1

4. 
``` ERROR:  relation "new_table" does not exist ```

``` LINE 1: select * from new_table; ```

5. COMMIT

6. 
``` id |   data    ```

``` ----+----------- ```

```  1 | test data ```

``` (1 row) ```

7. ROLLBACK

8. 
``` ERROR:  relation "new_table" does not exist ```

``` LINE 1: select * from new_table; ```

**Выводы и объяснения:**
Если транзакция зафиксирована, то изменения, внесённые в таблицу, становятся постоянными и видимыми во всех сеансах. В сеансе 2 запрос SELECT * FROM new_table вернёт данные, внесённые в таблицу. Если транзакция не зафиксирована, то изменения, внесённые в таблицу, не сохраняются.

#### Задача 4: Блокировка DDL
**Цель:** В сеансе 1 начать транзакцию и выполните SELECT * FROM iso_test; (даже если таблица пуста), затем попытаться в сеансе 2 выполнить DROP TABLE iso_test. Получится ли? Объяснить, почему.

**Выполненные действия:**
1. begin transaction isolation level read committed;
2. select * from iso_test;
3. drop table iso_test;

**Результаты:**
1. BEGIN

2. 
``` id |   data   ```

``` ----+----------- ```

```  1 | test data ```

``` (1 row) ```

3. 

**Выводы и объяснения:**
Выполнение drop table iso_test в сеансе 2 не получится из-за уровня изоляции read committed. Этот уровень гарантирует, что транзакция видит только зафиксированные изменения других транзакций, и попытка получить доступ к данным, которые ещё не зафиксированы, может привести к ошибкам.

### Модуль 2: Фантомное чтение и снимки

#### Задача 1: Фантомное чтение (Read Committed)
**Цель:** Создать пустую таблицу phantom_test (id INT) и продемонстрировать на уровне Read Committed, что аномалия "фантомное чтение" не предотвращается (вставка новых строк в другом сеансе становится видимой).

**Выполненные действия:**
1. create table phantom_test (id int);
2. insert into phantom_test values (1);
3. begin transaction isolation level read committed;
4. select * from phantom_test;
5. commit;
6. insert into phantom_test values (2);
7. commit;
8. select * from phantom_test;

**Результаты:**
1. CREATE TABLE
2. INSERT 0 1
3. BEGIN

4. 
``` id ```

``` ---- ```

```  1 ```

``` (1 row) ```

5. COMMIT
6. INSERT 0 1
7. COMMIT

8. 
``` id ```

``` ---- ```

```  1 ```

```  2 ```

``` (2 rows) ```

#### Задача 2: Невидимость удалений (Repeatable Read)
**Цель:** В сеансе 1 начать транзакцию с уровнем Repeatable Read (пока без запросов), в сеансе 2 удалить все строки из phantom_test и зафиксировать; в сеансе 1 выполнить SELECT * FROM phantom_test;. Увидятся ли удаленные строки? Выполнить в сеансе 1 запрос SELECT * FROM pg_database; (не касаясь phantom_test). Повлияет ли это на видимость строк в phantom_test при последующем запросе?

**Выполненные действия:**
1. begin transaction isolation level repeatable read;
2. delete from phantom_test where id < 3;
3. commit;
4. select * from phantom_test;
5. select * from pg_database;

**Результаты:**
1. BEGIN
2. DELETE 2
3. COMMIT

4. 
``` id ```

``` ---- ```

```  1 ```

```  2 ```

``` (2 rows) ```

5. 
```  oid  |  datname  | datdba | encoding | datlocprovider | datistemplate | datallowconn | datconnlimit | datfrozenxid | datminmxid | dattablespace | datcollate  |  datctype   | daticulocale | daticurules | datcollversion |               datacl                ```

``` -------+-----------+--------+----------+----------------+---------------+--------------+--------------+--------------+------------+---------------+-------------+-------------+--------------+-------------+----------------+------------------------------------- ```

```     5 | postgres  |     10 |        6 | c              | f             | t            |           -1 |          722 |          1 |          1663 | en_US.UTF-8 | en_US.UTF-8 |              |             | 2.39           | ```

``` 16385 | student   |  16384 |        6 | c              | f             | t            |           -1 |          722 |          1 |          1663 | en_US.UTF-8 | en_US.UTF-8 |              |             | 2.39           | ```

```     1 | template1 |     10 |        6 | c              | t             | t            |           -1 |          722 |          1 |          1663 | en_US.UTF-8 | en_US.UTF-8 |              |             | 2.39           | {=c/postgres,postgres=CTc/postgres} ```

```     4 | template0 |     10 |        6 | c              | t             | f            |           -1 |          722 |          1 |          1663 | en_US.UTF-8 | en_US.UTF-8 |              |             |                | {=c/postgres,postgres=CTc/postgres} ```

``` 16390 | lab02_db  |  16384 |        6 | c              | f             | t            |           -1 |          722 |          1 |          1663 | en_US.UTF-8 | en_US.UTF-8 |              |             | 2.39           | ```

``` (5 rows) ```

``` ~ ```

``` ~ ```

``` ~ ```

``` ~ ```

``` ~ ```

``` ~ ```

``` ~ ```

``` (END) ```

**Выводы и объяснения:**
Удалённые строки не будут видны в сеансе 1 при выполнении select * from phantom_test на уровне изоляции Repeatable Read. Это следует из того, что транзакция видит «снимок» (snapshot) данных на момент своего начала, и изменения, внесённые другими транзакциями во время выполнения транзакции, не видны. 

#### Задача 3: Транзакционность DDL
**Цель:** Убедиться, что DROP TABLE является транзакционной операцией (можно откатить).

**Выполненные действия:**
1. begin transaction isolation level read committed;
2. create table new_table (id int, data text);
3. drop table new_table;
4. rollback;
5. select * from new_table;

**Результаты:**
1. BEGIN
2. CREATE TABLE
3. DROP TABLE
4. ROLLBACK

5. 
``` ERROR:  relation "new_table" does not exist ```

``` LINE 1: select * from new_table; ```
```                      ^ ```

## Результаты выполнения

### Сводная таблица результатов
| Модуль | Задача | Статус | Ключевые наблюдения |
|--------|--------|--------|---------------------|
| 1 | 1 | ✅ Выполнено | Read Committed гарантирует, что транзакция видит только зафиксированные данные, исключая "грязное чтение" (чтение незафиксированных данных) |
| 1 | 2 | ✅ Выполнено | Repeatable Read обеспечивает, что повторное чтение одних данных вернёт тот же результат |
| 1 | 3 | ✅ Выполнено | Незафиксированные данные не сохраняются |
| 1 | 4 | ✅ Выполнено | Нельзя выполнить команду drop table в сеансе 2, пока изменения в таблице не зафиксированны в сеансе 1 |
| 2 | 1 | ✅ Выполнено | "Фантомное чтение" не предотвращается на уровне изоляции Read Committed |
| 2 | 2 | ✅ Выполнено | "Неповторяемое чтение" не предотвращается на уровне изоляции Repeatable Read |
| 2 | 3 | ✅ Выполнено | drop table является транзакционной операцией |

## Анализ и выводы

### Основные наблюдения
1. Уровни изоляции транзакций определяют, как данные изолируются друг от друга при выполнении параллельных транзакций, обеспечивая согласованность и целостность данных.
2. XMIN указывает идентификатор транзакции, создавшей версию строки. XMAX указывает идентификатор транзакции, которая удалила (или обновила) версию строки.
3. CTID — системный столбец в PostgreSQL, который указывает физическое расположение версии строки (кортежа) в таблице.
4. Фантомное чтение - при повторном выполнении запроса с идентичными условиями транзакция получает изменённый набор строк из-за добавления или удаления данных другой транзакцией.
5. Неповторяемое чтение - при повторном доступе к одним и тем же данным в рамках одной транзакции обнаруживается, что они были изменены другой завершённой транзакцией.
6. pageinspect - это модуль в PostgreSQL, который позволяет исследовать страницы баз данных на низком уровне. Он предоставляет функции для анализа внутренней структуры страниц и кортежей, включая их заголовки, видимость и содержимое данных.
7. ON_ERROR_ROLLBACK - это переменная в клиентском ПО psql для PostgreSQL, которая определяет, как обрабатывать ошибки внутри транзакций.
8. В PostgreSQL есть механизм экспорта и импорта снимков, который позволяет синхронизировать состояние базы данных в двух или более сеансах. Это необходимо, когда нужно видеть одно и то же содержимое базы данных, например, при работе с утилитой pg_dump, которая должна видеть одну и ту же картину данных для всех процессов.

